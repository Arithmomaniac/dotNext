<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Concept Types | .NEXT </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Concept Types | .NEXT ">
      
      <link rel="icon" href="../fav.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.json">
      <meta name="docfx:tocrel" content="toc.json">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/concept.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../doc_logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="concept-types">Concept Types</h1>

<p><a href="https://github.com/dotnet/csharplang/issues/110">Concept Types</a> is a proposed feature of C# and not yet implemented (at least in C# 11). DotNext Reflection library allows to use this feature in the current version of C#.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p><code>DotNext.Reflection</code> library doesn't receive new features anymore and will be deprecated soon. See <a href="https://github.com/dotnet/dotNext/discussions/142">this post</a> for more information.</p>
</div>
<p>If you are not familiar with type classes then read these articles first:</p>
<ul>
<li><a href="https://www.haskell.org/tutorial/classes.html">Type Classes</a> in Haskell programming language</li>
<li><a href="https://en.wikipedia.org/wiki/Type_class">Type Classes</a> on Wikipedia</li>
</ul>
<div class="CAUTION">
<h5>Caution</h5>
<p>Due to lack of native compiler support of this feature, any mistake in definition of concept type will not be highlighted at compile time.</p>
</div>
<p>The feature is based on strongly typed reflection so read <a href="reflection/fast.html">this</a> document first. Entry point to discover class members is <a class="xref" href="../api/DotNext.Reflection.Type-1.html">Type&lt;T&gt;</a>. Reflected members are cached to speed-up performance and typed by specific delegate type. The delegate describes signature of the reflected member. All types of members are supported: constructors, fields, methods, event, properties, indexer properties.</p>
<h1 id="defining-concept">Defining Concept</h1>
<p>The recommended code style for the concept type is a definition of static class with restrictions expressed as static fields. Let's define type class with single instance method and single static method:</p>
<pre><code class="lang-csharp">using DotNext.Reflection;
using DotNext.Runtime.CompilerServices;
using System.Runtime.CompilerServices;

[Concept]
public static class Parseable&lt;T&gt;
    where T: struct
{
    private delegate string ToStringMethod(in T @this, string format);

    private static readonly Func&lt;string, T&gt; parseMethod = Type&lt;T&gt;.Method.Require&lt;Func&lt;string, T&gt;&gt;(&quot;Parse&quot;, MethodLookup.Static);
    private static readonly ToStringMethod toStringMethod = Type&lt;T&gt;.Method.Require&lt;ToStringMethod&gt;(&quot;ToString&quot;, MethodLookup.Instance);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Parse(string text) =&gt; parseMethod(text);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string ToString(in T @this, string format) =&gt; toStringMethod(@this, format);
}
</code></pre>
<p><a class="xref" href="../api/DotNext.Runtime.CompilerServices.ConceptAttribute.html">ConceptAttribute</a> is required attribute that should be applied to the concept type definition.</p>
<p><code>Type&lt;T&gt;.Method.Require</code> is a method requirement declaration. In this example, type <em>T</em> should have two methods:</p>
<ul>
<li>Public static method <code>T Parse(string text)</code></li>
<li>Public instance method <code>string ToString()</code></li>
</ul>
<p>Existence of these methods checked at runtime (because no native support from C# compiler) when <code>Parseable</code> generic type is instantiated with actual generic arguments.</p>
<p>Now this concept can be used to call declared methods:</p>
<pre><code class="lang-csharp">int i = Parseable&lt;int&gt;.Parse(&quot;123&quot;); //i == 123
string str = Parseable&lt;int&gt;.ToString(i, &quot;X&quot;); //str == &quot;0x7B&quot;
</code></pre>
<p>The concept type allows to call static and instance members of type passed into generic parameter when it is not possible to predict actual generic argument.</p>
<p>The following concept type requires to have public instance property <code>Length</code> of type <code>int</code>.</p>
<pre><code class="lang-csharp">using DotNext.Reflection;
using DotNext.Runtime.CompilerServices;

[Concept]
public static class LengthSupport&lt;T&gt;
{
    private static readonly MemberGetter&lt;T, int&gt; lengthProp = Type&lt;T&gt;.Property&lt;int&gt;.Require(&quot;Length&quot;);

    public static int GetLength(in T @this) =&gt; lengthProp(@this);
}

var length = LengthSupport&lt;string&gt;.GetLength(&quot;Hello, world!&quot;); //length == 13
length = LengthSupport&lt;byte[]&gt;.GetLength(new byte[]{ 1, 2, 3 }); //length == 3
</code></pre>
<p>Now this concept allows to obtain value of <code>Length</code> property from any object.</p>
<p><code>Require</code> method is used to obtain instance member from the type specified as actual generic argument for type <code>Type&lt;T&gt;</code>. Static member can be obtained using <code>RequireStatic</code> family of methods. <code>Require</code> and <code>RequireStatic</code> are useful in the context of concept type declaration. If target type <em>T</em> doesn't have required member then these methods will throw one of <a class="xref" href="../api/DotNext.Reflection.ConstraintViolationException.html">ConstraintViolationException</a> ancestors:</p>
<ul>
<li><a class="xref" href="../api/DotNext.Reflection.MissingConstructorException.html">MissingConstructorException</a> if required constructor doesn't exist</li>
<li><a class="xref" href="../api/DotNext.Reflection.MissingMethodException.html">MissingMethodException</a> if required method or property getter/setter doesn't exist</li>
<li><a class="xref" href="../api/DotNext.Reflection.MissingFieldException.html">MissingFieldException</a> if required field doesn't exist</li>
<li><a class="xref" href="../api/DotNext.Reflection.MissingEventException.html">MissingEventException</a> if required event doesn't exist</li>
</ul>
<p>In the context of strongly typed reflection it is recommended to use alternative methods <code>Get</code> (for instance members) or <code>GetStatic</code> (for static members). These methods have same the same behavior as <code>Require</code>/<code>RequireStatic</code> but they don't throw exception. If member cannot be resolved then these methods return <strong>null</strong>.</p>
<h1 id="applying-concept">Applying Concept</h1>
<p>When concept type is declared, it can be used as a constraint for generic type parameter of class or method. <a class="xref" href="../api/DotNext.Runtime.CompilerServices.Concept.html">Concept</a> class allows to apply concept type to the generic parameter and verify constraints, thus, <em>fail fast</em> if actual generic argument doesn't meet to the them. <a class="xref" href="../api/DotNext.Runtime.CompilerServices.ConstraintAttribute.html">ConstraintAttribute</a> indicating that the specified generic parameter is constrained with one or more concept types.</p>
<pre><code class="lang-csharp">using DotNext.Runtime.CompilerServices;
using System;

public sealed class Formatter&lt;[Constraint(typeof(Parseable&lt;&gt;))] T&gt;
{
    static Formatter() =&gt; Concept.Assert(typeof(Parseable&lt;T&gt;));

    private readonly string format;

    public Formatter(string fmt) =&gt; format = fmt;

    public string Concat(in T first, in T second) 
        =&gt; Parsable&lt;T&gt;.ToString(first, format) + Parseable&lt;T&gt;.ToString(second, format);
}

var formatter = new Formatter&lt;long&gt;();          //constraint checked here
Console.WriteLine(formatter.Concat(1L, 2L));
</code></pre>
<p>Here, actual type <code>T</code> must satisfy to constraints defined by <code>Parseable</code> concept type, i.e. to have one instance method and one static method. <code>ConstraintAttribute</code> is an optional attribute aimed to inform the developer that generic parameter is constrained by one or more concept types. CLR doesn't rely on this attribute as well as Roslyn compiler. <code>Concept.Assert</code> enforces verification of generic argument correctness according with concept type. There are few reasons to place assertion into static constructor:</p>
<ol>
<li>Actual generic argument is accessible from static constructor</li>
<li>Assertion is called automatically before the first instance is created or any static members are referenced</li>
<li>Static constructor called once</li>
</ol>
<p>Invalid generic argument causes exception of type <code>ConstraintViolationException</code>.</p>
<p>However, assertion is optional and not recommended for use inside of generic methods. Let's remove assertion code from the static constructor. In this case, verfication will be performed only at the following line of code:</p>
<pre><code class="lang-csharp">var formatter = new Formatter&lt;long&gt;();          
Console.WriteLine(formatter.Concat(1L, 2L));//constraint checked here
</code></pre>
<p>This is contradiction to <em>fail fast</em> strategy because <code>Formatter</code> class can be instantiated with wrong actual generic argument.</p>
<h1 id="special-delegates">Special Delegates</h1>
<p><code>Type&lt;T&gt;</code> and its nested classes offer a rich set of methods for members binding. These methods reflect members as well-known delegate types defined in .NET library or DotNext Reflection library. In some cases, no one of these delegates can fit the requested member. For example, overloaded method <a href="https://docs.microsoft.com/en-us/dotnet/api/system.int32.tryparse">int.TryParse</a> with two parameters has <strong>out</strong> parameter. In this case, the supported set of delegates will not help. This issue can be resolved in two ways:</p>
<ul>
<li>Use custom delegate type, as it was shown in the example above (<code>ToStringMethod</code> delegate type)</li>
<li>Use special delegates provided by DotNext Reflection library:
<ul>
<li><a class="xref" href="../api/DotNext.Function-2.html">Function&lt;TArgs, TResult&gt;</a> for static methods with return type</li>
<li><a class="xref" href="../api/DotNext.Function-3.html">Function&lt;T, TArgs, TResult&gt;</a> for instance methods with return type</li>
<li><a class="xref" href="../api/DotNext.Procedure-1.html">Procedure&lt;TArgs&gt;</a> for static methods without return type</li>
<li><a class="xref" href="../api/DotNext.Procedure-2.html">Procedure&lt;T, TArgs&gt;</a> for instance methods without return type</li>
</ul>
</li>
</ul>
<p>These delegates able to represent the signature of any requested method and handled by <code>Type&lt;T&gt;</code> differently in comparison with regular delegate types.</p>
<div class="NOTE">
<h5>Note</h5>
<p>ref-like structs are not supported by these delegates because it is forbidden by compiler to pass such data types as actual generic arguments</p>
</div>
<p>These delegates accept input arguments in the form of the value type. Usually, the value type for the arguments is initialized on the stack. Therefore, all arguments will be passed through stack and .NET optimizations related to arguments passing are not possible.</p>
<p>It is allowed to use any custom value type to pass arguments. The arguments should be represented by public instance fields. Properties and private fields will be ignored by <code>Type&lt;T&gt;</code>. Therefore, it is recommended to use value tuples for passing arguments. Value tuples have native compiler support in C# and VB.NET so the source code still remain readable.</p>
<p>If parameter in the method signature is declared as <strong>ref</strong> our <strong>out</strong> then field in such structure should be of type <a class="xref" href="../api/DotNext.Reflection.Ref-1.html">Ref&lt;T&gt;</a>.</p>
<pre><code class="lang-csharp">using DotNext.Reflection;

//reflect static method as Function
Function&lt;(string text, Ref&lt;decimal&gt; result), bool&gt; tryParse = Type&lt;decimal&gt;.GetStaticMethod&lt;(string, Ref&lt;decimal&gt;), bool&gt;(nameof(decimal.TryParse));
//allocate arguments on the stack
(string text, Ref&lt;decimal&gt; result) args = default;  //or use var args = tryParse.ArgList(); with the same result
args.text = &quot;42&quot;;
tryParse(args);
decimal parsedValue = args.result;  //parsedValue == 42M
</code></pre>
<p>Let's assume that type of <code>text</code> parameter is unknown or unreachable from source code. In this case, it is possible to use <strong>object</strong> type with some performance overhead (but still much faster than .NET reflection):</p>
<pre><code class="lang-csharp">using DotNext.Reflection;

//reflect static method as Function
Function&lt;(object text, Ref&lt;decimal&gt; result), bool&gt; tryParse = Type&lt;decimal&gt;.GetStaticMethod&lt;(object, Ref&lt;decimal&gt;), bool&gt;(nameof(decimal.TryParse));
//allocate arguments on the stack
(object text, Ref&lt;decimal&gt; result) args = default;  //or use var args = tryParse.ArgList(); with the same result
args.text = &quot;42&quot;;
tryParse(args);
decimal parsedValue = args.result;  //parsedValue == 42M
</code></pre>
<h1 id="reusable-concepts">Reusable Concepts</h1>
<p>The library offers ready-to-use concept types:</p>
<ul>
<li><a class="xref" href="../api/DotNext.Number-1.html">Number&lt;T&gt;</a> represents any numeric type. This concept exposes operators, instance and static methods that are common to all numeric types in .NET Base Class Library</li>
<li><a class="xref" href="../api/DotNext.Disposable-1.html">Disposable&lt;T&gt;</a> represents any type implementing <em>Dispose pattern</em> even if target type doesn't implement <a href="https://docs.microsoft.com/en-us/dotnet/api/system.idisposable">IDisposable</a> interface directly</li>
<li><a class="xref" href="../api/DotNext.Runtime.CompilerServices.Awaitable-2.html">Awaitable&lt;T, TAwaitor&gt;</a> or <a class="xref" href="../api/DotNext.Runtime.CompilerServices.Awaitable-3.html">Awaitable&lt;T, TAwaitor, TResult&gt;</a> represents <em>awaitable pattern</em> which describes any type compatible with <strong>await</strong> operator</li>
<li><a class="xref" href="../api/DotNext.Record-1.html">Record&lt;T&gt;</a> represents <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record">record class</a></li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/concept.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        </div>
      </div>
    </footer>
  </body>
</html>
