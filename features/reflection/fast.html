<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Fast Reflection | .NEXT </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Fast Reflection | .NEXT ">
      
      <link rel="icon" href="../../fav.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/reflection/fast.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../doc_logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="fast-reflection">Fast Reflection</h1>

<p>Invocation of reflected members in .NET is slow. This happens because late-binding <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase.invoke">invocation</a> should provide type check of arguments for each call. DotNext Reflection library provides a way to invoke reflected members in strongly typed manner. It means that invocation parameters are typed and type safety is guaranteed by compiler. Moreover, this feature allows to invoke members with the same performance as they called without reflection. The reflected member can be converted into appropriate delegate instance for caching and further invocation. The binding process still performed dynamically and based on .NET reflection.</p>
<p><a class="xref" href="../../api/DotNext.Reflection.Reflector.html">Reflector</a> class provides methods for reflecting class members. The type of delegate instance which represents reflected member describes the signature of the method or constructor. But what the developer should do if one of constructor or method parameteters has a type that is not visible from the calling code (e.g. type has <strong>internal</strong> visibility modifier and located in third-party library)? This issue is covered by Reflection library with help of the following special delegate types:</p>
<ul>
<li><a class="xref" href="../../api/DotNext.Function-2.html">Function&lt;A, R&gt;</a> for static methods with return type</li>
<li><a class="xref" href="../../api/DotNext.Function-3.html">Function&lt;T, A, R&gt;</a> for instance methods with return type</li>
<li><a class="xref" href="../../api/DotNext.Procedure-1.html">Procedure&lt;A&gt;</a> for static methods without return type</li>
<li><a class="xref" href="../../api/DotNext.Procedure-2.html">Procedure&lt;T, A&gt;</a> for instance methods without return type</li>
</ul>
<p>These delegates can describe signature of arbitrary methods or constructors with a little performance cost: all arguments will passed through stack. As a result, they can be used if developer don't want to introduce a new delegate type for some untypical signatures (with <strong>ref</strong> or <strong>out</strong> parameters).</p>
<p>Combination of various delegate signatures and <code>Reflector</code> class provide configurable approach to fast reflection and allows to choose between convenience and performance. Moreover, it requires compile-time some knowledge about underlying types of parameters and declaring type. To reduce this complexity, .NEXT Reflection library offers lightweight fast reflection API represented by non-generic overloaded version of <code>Unreflect</code> extension method. Lightweight implementation is a dynamic compilation of member access code and exposes unified API surface for all supported member types in the form of single <a class="xref" href="../../api/DotNext.Reflection.DynamicInvoker.html">DynamicInvoker</a> delegate type. Invocation API is very similar to reflection provided by .NET out-of-the-box, but much more faster.</p>
<h1 id="constructor">Constructor</h1>
<p>Constructor can be reflected as delegate instance.</p>
<pre><code class="lang-csharp">using System.IO;
using DotNext.Reflection;

Func&lt;byte[], bool, MemoryStream&gt; ctor = typeof(MemoryStream).GetConstructor(new[] { typeof(byte[]), typeof(bool) }).Unreflect&lt;Func&lt;byte[], bool, MemoryStream&gt;&gt;();
using(var stream = ctor(new byte[] { 1, 10, 5 }, false))
{

}
</code></pre>
<p>The same behavior can be achieved using <em>Function</em> special delegate:</p>
<pre><code class="lang-csharp">using System.IO;
using DotNext.Reflection;

Function&lt;(byte[] buffer, bool writable), MemoryStream&gt; ctor = typeof(MemoryStream).GetConstructor(new[] { typeof(byte[]), typeof(bool) }).Unreflect&lt;Function&lt;(byte[], bool), MemoryStream&gt;&gt;();

var args = ctor.ArgList();
args.buffer = new byte[] { 1, 10, 5 };
args.writable = false;
using var stream = ctor(args);
</code></pre>
<p>Moreover, it is possible to use custom delegate type for reflection:</p>
<pre><code class="lang-csharp">using DotNext.Reflection;
using System.IO;

internal delegate MemoryStream MemoryStreamConstructor(byte[] buffer, bool writable);

MemoryStreamConstructor ctor = typeof(MemoryStream).GetConstructor(new[] { typeof(byte[]), typeof(bool) }).Unreflect&lt;MemoryStreamConstructor&gt;();
using var stream = ctor(new byte[] { 1, 10, 5 }, false);
</code></pre>
<p>Lightweight object construction can be achieved using overloaded non-generic <code>Unreflect</code> method:</p>
<pre><code class="lang-csharp">using DotNext.Reflection;
using System.IO;

var ctor = typeof(MemoryStream).GetConstructor(new[] { typeof(byte[]), typeof(bool) }).Unreflect();
using var stream = (MemoryStream)ctor(null, new byte[] { 1, 10, 5}, false);
</code></pre>
<h1 id="method">Method</h1>
<p>Static or instance method can be reflected as delegate instance. In case of instance method, first argument of the delegate should accept <strong>this</strong> argument:</p>
<ul>
<li><em>T</em> for reference type</li>
<li><em>ref T</em> for value type</li>
</ul>
<pre><code class="lang-csharp">using System.Numerics;
using DotNext.Reflection;

internal delegate byte[] ToByteArray(ref BigInteger @this);

var toByteArray = typeof(BigInteger).GetMethod(nameof(BigInteger)).Unreflect&lt;ToByteArray&gt;();
BigInteger i = 10;
var array = toByteArray(ref i);
</code></pre>
<p>If method contains <strong>ref</strong> our <strong>our</strong> parameter then then it is possible to use custom delegate, <em>Function</em> or <em>Procedure</em>. The following example demonstrates how to use <em>Function</em> to call a method with <strong>out</strong> parameter.</p>
<pre><code class="lang-csharp">using DotNext.Reflection;

Function&lt;(string text, decimal result), bool&gt; tryParse = typeof(decimal).GetMethod(nameof(decimal.TryParse), new[]{typeof(string), typeof(decimal).MakeByRefType()}).Unreflect&lt;Function&lt;(string, decimal), bool&gt;&gt;();

(string text, decimal result) args = tryParse.ArgList();
args.text = &quot;42&quot;;
tryParse(args);
decimal v = args.result;    //v == 42M
</code></pre>
<p><em>args</em> value passed into <em>Function</em>  instance by reference and contains all necessary arguments in the form of value tuple.</p>
<p>Let's assume than type of <code>text</code> parameter is not known at compile time or unreachable from source code because the type is declared in external library and has <strong>internal</strong> visibility modifier. In this case, the type of such parameter can be replaced with <strong>object</strong> data type. Of course, it will affect performance but still be much faster than classic .NET reflection.</p>
<pre><code class="lang-csharp">using DotNext.Reflection;

Function&lt;(object text, decimal result), bool&gt; tryParse = typeof(decimal).GetMethod(nameof(decimal.TryParse), new[]{typeof(string), typeof(decimal).MakeByRefType()}).Unreflect&lt;Function&lt;(object, decimal), bool&gt;&gt;();

(object text, decimal result) args = tryParse.ArgList();
args.text = &quot;42&quot;;
tryParse(args);
decimal v = args.result;    //v == 42M
</code></pre>
<p>Lightweight method invocation can be achieved using overloaded non-generic <code>Unreflect</code> method:</p>
<pre><code class="lang-csharp">using DotNext.Reflection;

var tryParse = typeof(decimal).GetMethod(nameof(decimal.TryParse), new[]{typeof(string), typeof(decimal).MakeByRefType()}).Unreflect();
object[] args = {&quot;42&quot;, decimal.Zero};
tryParse(null, args);
decimal v = (decimal)args[1];
</code></pre>
<h1 id="field">Field</h1>
<p>Static or instance field can obtained from <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.fieldinfo">FieldInfo</a> using <code>Unreflect</code> extension method declared in <a class="xref" href="../../api/DotNext.Reflection.Reflector.html">Reflector</a> class. This feature gives the power to work with field values using Reflection without performance loss.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>Managed pointer to the field value is mutable even if field is <strong>readonly</strong>. As a result, you can modify value of such field. It is responsibility of the developer to control access to read-only fields.</p>
</div>
<p>This is not the only way to obtain direct access to the field. <a class="xref" href="../../api/DotNext.Reflection.Field-1.html">Field&lt;V&gt;</a> and <a class="xref" href="../../api/DotNext.Reflection.Field-2.html">Field&lt;T,V&gt;</a> that can be returned by <a class="xref" href="../../api/DotNext.Reflection.Type-1.Field-1.html">Type&lt;T&gt;.Field&lt;T&gt;</a> provide access to static and field value respectively.</p>
<p>The following example demonstrates how to obtain managed pointer to the static and instance fields:</p>
<pre><code class="lang-csharp">using DotNext.Reflection;
using System.Reflection;

class MyClass
{
	private static long StaticField;

	private string instanceField;

	public MyClass(string str) =&gt; instanceField = str;
}

//change value of static field
ref long staticField = ref typeof(MyClass).GetField(&quot;StaticField&quot;, BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly).Unreflect&lt;long&gt;().Value;
staticField = 42L;

//change value of instance field
var obj = new MyClass();
ref string instanceField = ref obj.GetClass().GetField(&quot;instanceField&quot;, BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly).Unreflect&lt;string&gt;()[obj];
instanceField = &quot;Hello, world&quot;;
</code></pre>
<p>Lightweight field access can be achieved using overloaded non-generic <code>Unreflect</code> method which supports various optimization:</p>
<ul>
<li>Obtain field getter only</li>
<li>Obtain field setter only</li>
<li>Obtain field setter and getter combined into single instance of <a class="xref" href="../../api/DotNext.Reflection.DynamicInvoker.html">DynamicInvoker</a></li>
</ul>
<p>Third option is slower in comparison with others. Therefore if you expect one-directional access to the field then use proper optimization.</p>
<p>The following example demonstrates all possible optimization modes when generating field accessor:</p>
<pre><code class="lang-csharp">using DotNext.Reflection;
using System;
using System.Reflection;

var obj = new MyClass(&quot;Hello, world!&quot;);
//generate read-only accessor
var field = obj.GetClass().GetField(&quot;instanceField&quot;, BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);
DynamicInvoker invoker = field.Unreflect(BindingFlags.GetField);	
Console.WriteLine(invoker(obj));	//prints Hello, world!

//generate write-only accessor
invoker = field.Unreflect(BindingFlags.SetField);
invoker(obj, &quot;New field value&quot;);	//obj.instanceField = &quot;New field value&quot;

//generate read-write accessor
invoker = field.Unreflect();
invoker(obj, &quot;Hello, world!&quot;);
Console.WriteLine(invoker(obj));	//prints Hello, world!
</code></pre>
<h1 id="performance">Performance</h1>
<p>Invocation of members through special delegates is not a free lunch: you pay for passing arguments through the stack. But it still much faster than classic .NET Reflection. The following list describes performance impact using different approaches to reflection (from fast to slow).</p>
<table>
<thead>
<tr>
<th>Reflective call</th>
<th>Performance</th>
</tr>
</thead>
<tbody>
<tr>
<td>Custom delegate type or predefined delegate type which exactly describes the signature of expected method</td>
<td>the same or comparable to direct call (with nanoseconds overhead)</td>
</tr>
<tr>
<td>Special delegate types</td>
<td>x1,4 slower than direct call</td>
</tr>
<tr>
<td>Special delegate types with one or more unknown parameter types (when <strong>object</strong> used instead of actual type)</td>
<td>x2/x3 slower than direct call</td>
</tr>
<tr>
<td>Dynamically compiled <em>DynamicInvoker</em></td>
<td>x1.5/x2 slower than direct call and causes heap allocation of arguments of value type</td>
</tr>
<tr>
<td>Classic .NET Reflection</td>
<td>x10/x50 slower than direct call</td>
</tr>
</tbody>
</table>
<p>Read more about performance in <a href="../../benchmarks.html">Benchmarks</a> article.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/reflection/fast.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        </div>
      </div>
    </footer>
  </body>
</html>
