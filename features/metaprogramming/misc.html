<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Miscellaneous Statements | .NEXT </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Miscellaneous Statements | .NEXT ">
      
      <link rel="icon" href="../../fav.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/metaprogramming/misc.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../doc_logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="miscellaneous-statements">Miscellaneous Statements</h1>

<h1 id="writeline-expression">WriteLine Expression</h1>
<p><a class="xref" href="../../api/DotNext.Linq.Expressions.WriteLineExpression.html">WriteLineExpression</a> can be used to write line of the text in dynamically generated code. This expression supports several outputs for the text:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.console.out">Standard Output Stream</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.console.error">Standard Error Stream</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.debug.writeline#System_Diagnostics_Debug_WriteLine_System_Object_">Debug Output</a></li>
</ul>
<p>Additionally, Code Generator has static methods <code>WriteLine</code>, <code>WriteError</code> and <code>DebugMessage</code> that allow to place this expression as statement into lexical scope.</p>
<pre><code class="lang-csharp">using System;
using static DotNext.Metaprogramming.CodeGenerator;

var println = Lambda&lt;Action&lt;string&gt;&gt;(fun =&gt;
{
	WriteLine(fun[0]);
});
</code></pre>
<h1 id="assertion">Assertion</h1>
<p>Checks for a condition; if the condition is false, outputs messages and displays a message box that shows the call stack. This statement is available as static method <code>Assert</code> from Code Generator only.</p>
<p>The statement is relevant in DEBUG configuration only. In any other configurations, <code>Assert</code> method is ignored.</p>
<pre><code class="lang-csharp">using DotNext.Linq.Expressions;
using System;
using static DotNext.Metaprogramming.CodeGenerator;

var println = Lambda&lt;Action&lt;string&gt;&gt;(fun =&gt;
{
	Assert(fun.IsNotNull(), &quot;Argument is null&quot;);
	WriteLine(fun[0]);
});
</code></pre>
<h1 id="breakpoint">Breakpoint</h1>
<p>Signals a breakpoint to an attached debugger. This statement is available as static method <code>Breakpoint</code> from Code Generator only.</p>
<p>The statement is relevant in DEBUG configuration only. In any other configurations, <code>Breakpoint</code> method is ignored.</p>
<pre><code class="lang-csharp">using DotNext.Linq.Expressions;
using System;
using static DotNext.Metaprogramming.CodeGenerator;

var println = Lambda&lt;Action&lt;string&gt;&gt;(fun =&gt;
{
	Breakpoint();
	WriteLine(fun[0]);
});
</code></pre>
<h1 id="fragment">Fragment</h1>
<p>Regardless for rich set of helper methods for generating statements and expressions the code written for dynamic code generation may hard to read by developers. It reasonable to simplify construction of compound expressions or statements somehow. C# programming language supports creation of expression tree from single-line expression. This feature is utilized by Metaprogramming library and called <strong>expression fragment</strong>. The fragment is a body of lambda expression with parameters replaced by actual expressions from the context. It can be embedded as statement inside of multi-line lambda expression.</p>
<p>The following example demonstrates how to generate expression fragment:</p>
<pre><code class="lang-csharp">using DotNext.Linq.Expressions;
using System;

var fragment = ExpressionBuilder.Fragment&lt;Func&lt;int, int, int&gt;&gt;((x, y) =&gt; Math.Max(x, y), 10, 20);
//fragment is MethodCallExpression with two arguments: constant values 10 and 20 of type int
</code></pre>
<p>Static method <code>Embed</code> from Code Generator can be used to embed the expression fragment as statement into lexical scope of the multi-line lambda expression:</p>
<pre><code class="lang-csharp">using System;
using static DotNext.Metaprogramming.CodeGenerator;

var greeting = Lambda&lt;Action&lt;string&gt;&gt;(fun =&gt;
{
	Embed&lt;Action&lt;string&gt;&gt;(str =&gt; Console.WriteLine(&quot;Hello, {0}&quot;, str), fun[0]);
});

// the generated code is

new Action&lt;string&gt;(str =&gt; Console.WriteLine(&quot;Hello, {0}&quot;, str)));
</code></pre>
<h1 id="statement">Statement</h1>
<p>Migration of third-party code from plain <em>Expression Trees</em> to .NEXT Metaprogramming can be challenging due to differences in programming model. The code based on <a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.expressions.expression">Expression</a> class implements construction of expression trees. The code based on <code>CodeGenerator</code> class implements natural flow of the code: each call of static method represents a single statement. <code>CodeGenerator.Statement</code> static method bridges the gap between two programming model and simplifies code migration:</p>
<pre><code class="lang-csharp">using System;
using static DotNext.Metaprogramming.CodeGenerator;

var greeting = Lambda&lt;Func&lt;int, int, int&gt;&gt;(fun =&gt;
{
	Statement(Expression.Add(fun[0], fun[1]));
});

// the generated code is
new Func&lt;int, int, int&gt;((x, y) =&gt; x + y);
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/metaprogramming/misc.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        </div>
      </div>
    </footer>
  </body>
</html>
