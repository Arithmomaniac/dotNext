<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Value Type Enhancements | .NEXT </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Value Type Enhancements | .NEXT ">
      
      <link rel="icon" href="../../fav.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/core/valuetype.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../doc_logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="value-type-enhancements">Value Type Enhancements</h1>

<p>It's a challenge to implement <em>Equals</em> and <em>GetHashCode</em> methods for custom value type. Moreover, third-party library may provide value type without these methods and without overloaded equality/inequality operators. As a result, there is no way to identify whether the struct value is the default value.</p>
<p>.NEXT library provides generic methods for equality check and hash code calculation for any value type. These methods are located in <a class="xref" href="../../api/DotNext.BitwiseComparer-1.html">BitwiseComparer</a> and <a class="xref" href="../../api/DotNext.Runtime.Intrinsics.html">Intrinsics</a> classes and not extension methods to avoid ambiguity with overridden methods.</p>
<pre><code class="lang-csharp">using DotNext;
using System;

var guid = Guid.NewGuid();
BitwiseComparer&lt;Guid&gt;.Equals(guid, new Guid());    //false
BitwiseComparer&lt;Guid&gt;.GetHashCode(guid);
Intrinsics.IsDefault(guid);    //false
Intrinsics.IsDefault(new Guid());  //true
BitwiseComparer&lt;Guid&gt;.Compare(guid, new Guid());   // greater than 0
</code></pre>
<p>These methods use bitwise representation of struct in memory, not reflection tricks. Therefore, they are optimized for the best performance. Especially, for value types with many fields bitwise equality can demonstrate better performance in comparison with field-by-field comparison typically used for custom <em>Equals</em> implementation. Therefore, bitwise equality and hash code computation can be used in custom implementation of <em>Equals</em> and <em>GetHashCode</em> to save the time and the best performance.</p>
<pre><code class="lang-csharp">using DotNext;
using System;

public struct MyStruct: IEquatable&lt;MyStruct&gt;
{
    private int fieldA;
    private int fieldB;
    private int fieldC;

    public bool Equals(MyStruct other) =&gt; BitwiseComparer&lt;MyStruct&gt;.Equals(this, other);

    public override bool Equals(object other) =&gt; other is MyStruct typed &amp;&amp; Equals(typed);

    public override int GetHashCode() =&gt; BitwiseComparer&lt;MyStruct&gt;.GetHashCode(this);
}
</code></pre>
<p>Additionally, bitwise hash code computation method may accept custom hash code algorithm. Check API documentation for more information.</p>
<h1 id="fast-bitwise-cast-between-value-types">Fast bitwise cast between value types</h1>
<p>The library provides fast way to convert one unmanaged value type into another even if value type doesn't provide custom implicit or explicit type cast operator. This logic is provided by extension method <code>Bitcast</code>. Bitwise cast can be performed between two value types of different size.</p>
<pre><code class="lang-csharp">using DotNext.Runtime;

Intrinsics.Bitcast(20, out bool value); //value is true
Intrinsics.Bitcast(0, out bool value);  //value is false
</code></pre>
<p>The following example demonstrates how to extract content of the <em>Guid</em> data type.</p>
<pre><code class="lang-csharp">using DotNext.Runtime;

internal struct GuidRawData //Guid size is 16 bytes
{
    internal ulong Component1;
    internal ulong Component2;
}

Intrinsics.Bitcast(Guid.NewGuid, out GuidRawData data);
data.Component1 = 0;
Intrinsics.Bitcast(data, out Guid guid);    //convert back to Guid
</code></pre>
<p><code>Bitcast</code> provides bitwise copy of the original structure so it is very fast.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/core/valuetype.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        </div>
      </div>
    </footer>
  </body>
</html>
