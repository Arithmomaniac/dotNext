<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Synchronization Enhancements | .NEXT </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Synchronization Enhancements | .NEXT ">
      
      <link rel="icon" href="../../fav.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/core/sync.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../doc_logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="synchronization-enhancements">Synchronization Enhancements</h1>

<p>.NET class library provides different ways to organize synchronized access to the resource shared between multiple threads. These synchronization mechanisms are have differences in their API and require to pay more attention to how to acquire and release resources. For example, <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/lock-statement">lock statement</a> can acquire and release resource in more safely way than <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.semaphoreslim">Semaphore</a> or <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim">ReaderWriterLock</a>. Last two synchronization mechanisms force the developer to use <strong>try-finally</strong> statement manually.</p>
<p>.NEXT provides unified representation of the resource lock using the following mechanisms:</p>
<ul>
<li>Monitor</li>
<li>Reader lock</li>
<li>Upgradeable lock</li>
<li>Writer lock</li>
<li>Semaphore</li>
</ul>
<p>This unification is implemented in the form of the single type <a class="xref" href="../../api/DotNext.Threading.Lock.html">Lock</a>. It exposes the same set of acquisition methods for each lock type described above. The acquired lock is represented by <a class="xref" href="../../api/DotNext.Threading.Lock.Holder.html">lock holder</a>. The only purpose of this object is to hold the acquired lock. The lock can be released using <code>Dispose</code> method of the holder.</p>
<pre><code class="lang-csharp">using DotNext.Threading;
using System.Threading;

using var semaphore = new SemaphoreSlim();
using var @lock = Lock.Semaphore(semaphore);
//acquires the lock
using (@lock.Acquire())
{
}

using var rwlock = new ReaderWriterLockSlim();
using var @lock = Lock.WriteLock(rwLock);
//acquires the writer lock
if (@lock.TryAcquire(out Lock.Holder holder))
    using (holder)
    {

    }
</code></pre>
<h1 id="built-in-readerwriter-synchronization">Built-in Reader/Writer Synchronization</h1>
<p>Exclusive lock such as monitor lock may not be applicable due to performance reasons for some data types. For example, exclusive lock for dictionary or list is redundant because there are two consumers of these objects: writers and readers.</p>
<p>DotNext library provides several extension methods for more granular control over synchronization of any reference type:</p>
<ul>
<li><code>AcquireReadLock</code> acquires reader lock</li>
<li><code>AcquireWriteLock</code> acquires exclusive lock</li>
<li><code>AcquireUpgradeableReadLock</code> acquires read lock which can be upgraded to write lock</li>
</ul>
<p>These methods allow to turn any thread-unsafe object into thread-safe object with precise control in context of multithreading access.</p>
<pre><code class="lang-csharp">using System.Text;
using DotNext.Threading;

var builder = new StringBuilder();

//reader
using (builder.AcquireReadLock())
{
    Console.WriteLine(builder.ToString());
}

//writer
using (builder.AcquireWriteLock())
{
    builder.Append(&quot;Hello, world!&quot;);
}
</code></pre>
<p>For more information check extension methods inside of <a class="xref" href="../../api/DotNext.Threading.LockAcquisition.html">LockAcquisition</a> class.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/core/sync.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        </div>
      </div>
    </footer>
  </body>
</html>
