<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Optional Type | .NEXT </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Optional Type | .NEXT ">
      
      <link rel="icon" href="../../fav.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/core/optional.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../doc_logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="optional-type">Optional Type</h1>

<p><a class="xref" href="../../api/DotNext.Optional-1.html">Optional&lt;T&gt;</a> is a container which may or may not contain a value. <a href="https://docs.microsoft.com/en-us/dotnet/api/system.nullable-1">Nullable&lt;T&gt;</a> type can work with value types only. <code>Optional&lt;T&gt;</code> data type can work with reference and value type both.</p>
<p>The following example demonstrates usage of this type:</p>
<pre><code class="lang-csharp">using DotNext;
using DotNext.Collections.Generic;

IEnumerable&lt;int&gt; array = new int[] { 1, 2, 3 };
Optional&lt;int&gt; i = array.FirstOrNone(); //extension method from Sequence class
var value = (int)i; //cast is supported
if(i.TryGet(out value))
{
    //if i has value
}
if(i)   //if i has value
{
    value = i.Value;
}
value = i.OrThrow&lt;ArgumentException&gt;();
value = i.Or(-1);   //returns -1 if i has no value
value = i.OrDefault(); //returns default(int) if i has no value
value = i.OrInvoke(() =&gt; 10); //calls lambda if i has no value
</code></pre>
<p><code>Nullable&lt;T&gt;</code> and <code>Optional&lt;T&gt;</code> are mutually convertible types with help of <a class="xref" href="../../api/DotNext.Optional.html">extension methods</a>.</p>
<h1 id="null-vs-undefined">Null vs Undefined</h1>
<p>Let's take a look at the following code:</p>
<pre><code class="lang-csharp">using DotNext;
using System;

static Optional&lt;string&gt; FirstOrNull(string[] array)
    =&gt; array.Length &gt; 0 ? array[0] : Optional&lt;string&gt;.None;

string[] array1 = { null };
Optional&lt;string&gt; first1 = FirstOrNull(array1);

string[] array2 = Array.Empty&lt;string&gt;();
Optional&lt;string&gt; first2 = FirstOrNull(array2);
</code></pre>
<p><code>HasValue</code> property of both values <code>first1</code> and <code>first2</code> is <strong>false</strong>. However, <code>first1</code> actually represents the first element from the array. But the element is <strong>null</strong>. <code>first2</code> is empty because the array is empty. This situation is equivalent to the following code:</p>
<pre><code class="lang-csharp">using DotNext;

var first1 = new Optional&lt;string&gt;(null);
var first2 = Optional&lt;string&gt;.None;    //or default(Optional&lt;string&gt;)
</code></pre>
<p>Is it possible to distinguish the absence of value from <strong>null</strong> value? The answer is yes. There are two additional properties:</p>
<ul>
<li><code>IsNull</code> returns <strong>true</strong> if underlying value is <strong>null</strong></li>
<li><code>IsUndefined</code> returns <strong>true</strong> if underlying value is not defined</li>
</ul>
<p>Now it's possible to apply additional logic to the optional result:</p>
<pre><code class="lang-csharp">Optional&lt;string&gt; first = FirstOrNull(array);

switch (first)
{
    case { HasValue: true }:
        // value is present
        string result = first.Value;
        break;
    case { IsNull: true }:
        // value is null
        break;
    default:
        // value is undefined
        break;
}
</code></pre>
<p>Undefined <code>Optional&lt;T&gt;</code> instance can be produced only by <code>None</code> static property or by default value:</p>
<pre><code class="lang-csharp">using DotNext;

Optional&lt;string&gt;.None; // IsUndefined == true, IsNull == false
new Optional&lt;string&gt;(); // IsUndefined == true, IsNull == false
default(Optional&lt;string&gt;);  // IsUndefined == true, IsNull == false
new Optional&lt;string&gt;(null); // IsUndefined == false, IsNull == true
</code></pre>
<p>There is also convenient factory methods for creating optional values:</p>
<pre><code class="lang-csharp">using DotNext;

Optional&lt;string&gt; nullValue = Optional.Null&lt;string&gt;();       // undefined
Optional&lt;string&gt; undefinedValue = Optional.None&lt;string&gt;();  // null
Optional&lt;string&gt; value = Optional.Some(&quot;Hello, world!&quot;);    // not null
</code></pre>
<p>Behavior of <code>Equals</code> method and equality operators depend on underlying value and its presence. Undefined and null values behave similarily to JavaScript.</p>
<pre><code class="lang-csharp">using DotNext;

Optional.Null&lt;string&gt;() == Optional.Null&lt;string&gt;(); // true
Optional.None&lt;string&gt;() == Optional.None&lt;string&gt;(); // true
Optional.None&lt;string&gt;() == Optional.Null&lt;string&gt;(); // false
</code></pre>
<p>The following table describes relationship between <code>HasValue</code>, <code>IsNull</code> and <code>IsUndefined</code> properties for nullable type <code>T</code> (reference type, <code>Nullable&lt;T&gt;</code> or <code>Optional&lt;T&gt;</code>):</p>
<table>
<thead>
<tr>
<th>HasValue</th>
<th>IsNull</th>
<th>IsUndefined</th>
</tr>
</thead>
<tbody>
<tr>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>The following table describes relationship between <code>HasValue</code>, <code>IsNull</code> and <code>IsUndefined</code> properties for non-nullable type <code>T</code> (all value types except <code>Nullable&lt;T&gt;</code> and <code>Optional&lt;T&gt;</code>):</p>
<table>
<thead>
<tr>
<th>HasValue</th>
<th>IsNull</th>
<th>IsUndefined</th>
</tr>
</thead>
<tbody>
<tr>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>true</td>
</tr>
</tbody>
</table>
<h1 id="json-serialization">JSON serialization</h1>
<p><a class="xref" href="../../api/DotNext.Optional-1.html">Optional&lt;T&gt;</a> is compatible with JSON serialization provided by <code>System.Text.Json</code> namespace. You can enable support of this type using <a class="xref" href="../../api/DotNext.Text.Json.OptionalConverterFactory.html">OptionalConverterFactory</a> converter. The converter can be applied to the property or field directly using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonconverterattribute">JsonConverterAttribute</a> attribute or it can be registered via <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.converters">Converters</a> property.</p>
<p>If the value of <code>Optional&lt;T&gt;</code> is undefined, then property will be completely removed from serialized JSON document. This is useful when you want to describe Data Transfer Object for your resource in REST API that allows partial updates with <em>PATCH</em> HTTP method. To make this magic work, you also need to apply <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonignoreattribute">JsonIgnoreAttribute</a> with condition equal to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonignorecondition">JsonIgnoreCondition.WhenWritingDefault</a>. This condition tells JSON serializer to drop the field if its value is equal to default value. As we know, the default value of <code>Optional&lt;T&gt;</code> is always undefined. The following example demonstrates how to design DTO with optional JSON fields:</p>
<pre><code class="lang-csharp">using DotNext.Text.Json;
using System.Text.Json;

public sealed class JsonObject
{
    [JsonConverter(typeof(OptionalConverterFactory))]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public Optional&lt;int&gt; IntegerValue { get; set; } // optional field

    [JsonConverter(typeof(OptionalConverterFactory))]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public Optional&lt;string&gt; StringField { get; set; } // optional field

    public bool BoolField{ get; set; } // required field which is always presented in JSON
}
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/core/optional.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        </div>
      </div>
    </footer>
  </body>
</html>
