<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>ValueTask Completion Source | .NEXT </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="ValueTask Completion Source | .NEXT ">
      
      <link rel="icon" href="../../fav.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/threading/tasksrc.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../doc_logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="valuetask-completion-source">ValueTask Completion Source</h1>

<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcompletionsource-1">TaskCompletionSource&lt;T&gt;</a> from .NET standard library represents the producer side of a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1">Task&lt;T&gt;</a>. Once the source is completed, it cannot be reused. It happens because of nature of the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task">Task</a> type: task instance can be awaited multiple times. This is not true for <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.valuetask">value task</a> because it must be awaited once. See <a href="https://itnext.io/why-can-a-valuetask-only-be-awaited-once-31169b324fa4">this</a> article for detailed explanation.</p>
<p>The fact that value task must be consumed only once is actively used by <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.asyncvaluetaskmethodbuilder">AsyncValueTaskMethodBuilder</a> when constructing state machine for async methods in C#. The actual implementation of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.sources.ivaluetasksource">IValueTaskSource</a> can be reused between multiple instances of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.valuetask">ValueTask</a>. When the task is completed, the builder waits for consumption of the task result. When the result is acquired, the source can be reset and placed to the pool for future use. However, .NET standard library doesn't offer this behavior as a public API.</p>
<p>.NEXT Threading library provides the producer side of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.valuetask">ValueTask</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.valuetask-1">ValueTask&lt;T&gt;</a> suitable for pooling and reuse: <a class="xref" href="../../api/DotNext.Threading.Tasks.ValueTaskCompletionSource.html">ValueTaskCompletionSource</a> and <a class="xref" href="../../api/DotNext.Threading.Tasks.ValueTaskCompletionSource-1.html">ValueTaskCompletionSource&lt;T&gt;</a> respectively. In contrast to <code>TaskCompletionSource</code> type from .NET, these types can reused for multiple value tasks. As a result, you can place them to the pool and reduce memory allocation associated with tasks in async context. Additionally, these types support timeout and cancellation tracking.</p>
<p>Completion source can be in the following states:</p>
<ul>
<li><strong>Ready for use</strong> means that the source can be used to obtain a fresh incompleted value task</li>
<li><strong>Completed</strong> means that the producer turns the source into completed state (completed successfully or with exception, canceled, timed out)</li>
<li><strong>Consumed</strong> means that the value task is awaited by consumer side. The source can be reused only after this event</li>
</ul>
<p>Completion source offers the following extension points:</p>
<ul>
<li><code>AfterConsumed</code> virtual method that is called automatically when the task is awaited by the consumer. You can override it to return completion source back to the pool.</li>
<li><code>OnTimeout</code> virtual method that is called when the task is timed out. The method allows to override the result to be passed to the task consumer. By default, it turns the task into failed state with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.timeoutexception">TimeoutException</a> exception.</li>
<li><code>OnCanceled</code> virtual method that is called when the task is canceled. The method allows to override the result to be passed to the task consumer. By default, it turns the task into failed state with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.operationcanceledexception">OperationCanceledException</a> exception.</li>
</ul>
<p><code>CreateTask(TimeSpan timeout, CancellationToken token)</code> method allows to obtain the task from the source. The method must be called only if previously produced task has been awaited and <code>Reset</code> method has been called. The produced task can be completed using <code>TrySetCanceled</code>, <code>TrySetException</code> or <code>TrySetResult</code> methods.</p>
<p>The common usage pattern for this kind of completion source:</p>
<ol>
<li>Create or obtain an instance of completion source from the pool</li>
<li>Call <code>CreateTask</code> method (timeout and cancellation token are optional)</li>
<li>Return the task to consumer</li>
<li>Complete the task with <code>TrySetCanceled</code>, <code>TrySetException</code> or <code>TrySetResult</code> methods</li>
<li>Override <code>AfterConsumed</code> method and call <code>Reset</code> method on completion source, then return completion source back to the pool</li>
</ol>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/threading/tasksrc.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        </div>
      </div>
    </footer>
  </body>
</html>
