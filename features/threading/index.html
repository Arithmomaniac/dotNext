<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Asynchronous Locks | .NEXT </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Asynchronous Locks | .NEXT ">
      
      <link rel="icon" href="../../fav.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/threading/index.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../doc_logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="asynchronous-locks">Asynchronous Locks</h1>

<p>Lock acquisition operation may blocks the caller thread. Reader/writer lock from .NET library doesn't have async versions of lock acquisition methods as well as <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.monitor">Monitor</a>. To avoid this, DotNext Threading library provides asynchronous non-blocking alternatives of these locks.</p>
<div class="CAUTION">
<h5>Caution</h5>
<p>Non-blocking and blocking locks are two different worlds. It is not recommended to mix these API in the same part of application. The lock acquired with blocking API located in <a class="xref" href="../../api/DotNext.Threading.Lock.html">Lock</a>, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.monitor">Monitor</a> or <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim">ReaderWriteLockSlim</a> is not aware about the lock acquired asynchronously with <a class="xref" href="../../api/DotNext.Threading.AsyncLock.html">AsyncLock</a>, <a class="xref" href="../../api/DotNext.Threading.AsyncExclusiveLock.html">AsyncExclusiveLock</a> or <a class="xref" href="../../api/DotNext.Threading.AsyncReaderWriterLock.html">AsyncReaderWriterLock</a>. The only exception is <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.semaphoreslim">SemaphoreSlim</a> because it contains acquisition methods in blocking and non-blocking manner at the same time.</p>
</div>
<p>All non-blocking synchronization mechanisms are optimized in terms of memory allocations. If lock acquisitions are not caused in the same time from different application tasks running concurrently then heap allocation associated with waiting queue will not happen.</p>
<p>Asynchronous locks don't rely on the caller thread. The caller thread never blocks so there is no concept of lock owner thread. As a result, these locks are not reentrant.</p>
<p>It is hard to detect root cause of deadlocks occurred by asynchronous locks so use them carefully.</p>
<p><a class="xref" href="../../api/DotNext.Threading.AsyncLock.html">AsyncLock</a> is a unified representation of the all supported asynchronous locks:</p>
<ul>
<li>Exclusive lock</li>
<li><a class="xref" href="../../api/DotNext.Threading.AsyncSharedLock.html">Shared lock</a></li>
<li>Reader lock</li>
<li>Writer lock</li>
<li>Semaphore</li>
</ul>
<p>The only one synchronization object can be shared between blocking and non-blocking representations of the lock.</p>
<pre><code class="lang-csharp">using DotNext.Threading;
using System.Threading;

var semaphore = new SemaphoreSlim(0, 1);
var syncLock = Lock.Semaphore(semaphore);
var asyncLock = AsyncLock.Semaphore(semaphore);

//thread #1
using (syncLock.Acquire())
{

}

//thread #2
using (await asyncLock.AcquireAsync(CancellationToken.None))
{

}
</code></pre>
<p><code>AsyncLock</code> implementing <a href="https://docs.microsoft.com/en-us/dotnet/api/system.iasyncdisposable">IAsyncDisposable</a> interface for graceful shutdown if supported by underlying lock type. The following lock types have graceful shutdown:</p>
<ul>
<li><a href="exclusive.html">AsyncExclusiveLock</a></li>
<li><a href="rwlock.html">AsyncReaderWriterLock</a></li>
<li><a class="xref" href="../../api/DotNext.Threading.AsyncExclusiveLock.html">AsyncSharedLock</a></li>
<li><a href="exchanger.html">AsyncExchanger</a></li>
</ul>
<p>Details of graceful shutdown described in related articles.</p>
<h1 id="built-in-readerwriter-synchronization">Built-in Reader/Writer Synchronization</h1>
<p>Exclusive lock may not be applicable due to performance reasons for some data types. For example, exclusive lock for dictionary or list is redundant because there are two consumers of these objects: writers and readers.</p>
<p>.NEXT Threading library provides several extension methods for more granular control over synchronization of any reference type:</p>
<ul>
<li><code>AcquireReadLockAsync</code> acquires reader lock asynchronously</li>
<li><code>AcquireWriteLockAsync</code> acquires exclusive lock asynchronously</li>
</ul>
<p>These methods allow to turn any thread-unsafe object into thread-safe object with precise control in context of multithreading access.</p>
<pre><code class="lang-csharp">using DotNext.Threading;
using System.Text;

var builder = new StringBuilder();

//reader
using (builder.AcquireReadLockAsync(CancellationToken.None))
{
    Console.WriteLine(builder.ToString());
}

//writer
using (builder.AcquireWriteLockAsync(CancellationToken.None))
{
    builder.Append(&quot;Hello, world!&quot;);
}
</code></pre>
<p>For more information check extension methods inside of <a class="xref" href="../../api/DotNext.Threading.LockAcquisition.html">AsyncLockAcquisition</a> class.</p>
<h1 id="custom-synchronization-primitive">Custom synchronization primitive</h1>
<p><a class="xref" href="../../api/DotNext.Threading.QueuedSynchronizer-1.html">QueuedSynchronizer&lt;TContext&gt;</a> provides low-level infrastructure for writing custom synchronization primitives for asynchronous code. It uses the same <a class="xref" href="../../api/DotNext.Threading.QueuedSynchronizer.html">synchronization engine</a> as other primitives shipped with the library: <a class="xref" href="../../api/DotNext.Threading.AsyncExclusiveLock.html">AsyncExclusiveLock</a>, <a class="xref" href="../../api/DotNext.Threading.AsyncReaderWriterLock.html">AsyncReaderWriterLock</a>, etc. The following example demonstrates how to write custom async-aware reader-writer lock:</p>
<pre><code class="lang-csharp">using DotNext.Threading;

// bool indicates lock type:
// false - read lock
// true - write lock
class MyExclusiveLock : QueuedSynchronizer&lt;bool&gt;
{
    // = 0 - no lock acquired
    // &gt; 0 - read lock
    // &lt; 0 - write lock
    private int readersCount;

    public MyExclusiveLock()
        : base(null)
    {
    }

    public ValueTask AcquireReadLockAsync(CancellationToken token)
        =&gt; base.AcquireAsync(false, token);

    public void ReleaseReadLock(CancellationToken token)
        =&gt; base.Release(false);

    public ValueTask AcquireWriteLockAsync(CancellationToken token)
        =&gt; base.AcquireAsync(true, token);

    public void ReleaseWriteLock()
        =&gt; base.Release(true);

    // write lock cannot be acquired if there is at least one read lock, or single write lock
    protected override bool CanAcquire(bool writeLock)
        =&gt; writeLock ? readersCount is 0 : readersCount &gt;= 0;

    protected override void AcquireCore(bool writeLock)
        =&gt; readersCount = writeLock ? -1 : readersCount + 1;

    protected override void ReleaseCore(bool writeLock)
        =&gt; readersCount = writeLock ? 0 : readersCount - 1;
}
</code></pre>
<h1 id="diagnostics">Diagnostics</h1>
<p>All synchronization primitives for asynchronous code mostly derive from <a class="xref" href="../../api/DotNext.Threading.QueuedSynchronizer.html">QueuedSynchronized</a> class that exposes a set of important diagnostics counters:</p>
<ul>
<li><code>LockContentionCounter</code> allows to measure a number of lock contentions detected in the specified time period</li>
<li><code>LockDurationCounter</code> allows to measure the amount of time spend by the suspended caller in the suspended state</li>
</ul>
<h1 id="debugging">Debugging</h1>
<p>In addition to diagnostics tools, <a class="xref" href="../../api/DotNext.Threading.QueuedSynchronizer.html">QueuedSynchronized</a> and all its derived classes support a rich set of debugging tools:</p>
<ul>
<li><code>TrackSuspendedCallers</code> method allows to enable tracking information about suspended caller. This method has effect only when building project using <code>Debug</code> configuration</li>
<li><code>SetCallerInformation</code> method allows to associate information with the caller if it will be suspended during the call of <code>WaitAsync</code>. This method has effect only when building project using <code>Debug</code> configuration</li>
<li><code>GetSuspendedCallers</code> method allows to capture a list of all suspended callers. The method is working only if tracking is enabled via <code>TrackSuspendedCallers</code> method. Typically, this method should be used in debugger's <em>Watch</em> window when all threads are paused</li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/threading/index.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        </div>
      </div>
    </footer>
  </body>
</html>
