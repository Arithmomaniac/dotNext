<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Gossip-based Communication | .NEXT </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Gossip-based Communication | .NEXT ">
      
      <link rel="icon" href="../../fav.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/cluster/gossip.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../doc_logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="gossip-based-communication">Gossip-based Communication</h1>

<p><a href="https://en.wikipedia.org/wiki/Gossip_protocol">Gossip-based communication</a> is a way to spread a message (rumor) across all cluster nodes using infection-style message exchange. This approach is very efficient in comparison to naive broadcasting especially in large-scale clusters. But how the node knows how to join the cluster and discover other peers? The answer is <em>membership protocol</em> that allows to discover and keep the view of cluster members.</p>
<h1 id="hyparview">HyParView</h1>
<p><a href="https://asc.di.fct.unl.pt/%7Ejleitao/pdf/dsn07-leitao.pdf">HyParView</a> is an implementation of <em>membership protocol</em> for peers that want to communicate with each other using infection-style message exchange. This algorithm is highly scalable up to thousands of nodes. However, it has one major drawback: every node has partial view of the entire cluster.</p>
<p>.NEXT offers transport-agnostic implementation of HyParView algorithm represented by <a class="xref" href="../../api/DotNext.Net.Cluster.Discovery.HyParView.PeerController.html">PeerController</a> class. It's an entry point for building a peer with messaging capabilities. The controller is responsible for all key aspects of the algorithm:</p>
<ul>
<li>Implementation of joining procedure</li>
<li>Maintaining a list of neighbors</li>
<li>Announcing of new peers</li>
<li>Removing peers from the mesh</li>
</ul>
<p><a class="xref" href="../../api/DotNext.Net.Cluster.Discovery.HyParView.IPeerConfiguration.html">IPeerConfiguration</a> interface provides the configuration model of HyParView-enabled peer. When the peer configured properly, you need to bootstrap the controller using <code>StartAsync</code> method. The method accepts an address of the <em>contact node</em> optionally. This address is not needed when you starting the first peer in the mesh. However, if you already have a mesh of peers then you need to announce a new peer correctly. <em>Contact node</em> is responsible for announcing joined peer across all peers in the mesh. There is no preference in choosing the appropriate node for that purpose.</p>
<p>When the node is joined to the mesh then it will be able to discover a list of neighbors automatically. <code>PeerDiscovered</code> and <code>PeerGone</code> events of <code>PeerController</code> class provide ability to track changes in the list of visible peers. <code>Neighbors</code> property provides a list of the peers visible by the local node.</p>
<p><code>StopAsync</code> method provides a way for graceful shutdown of the node. All neighbors will be informed that the stopped node is no longer accessible and it must be removed from the list of neighbors.</p>
<p><code>EnqueueBroadcastAsync</code> method can be used to broadcast the message (rumor) to all neighbors. This is a core of Gossip-based messaging. The method requires an implementation of <a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.Gossip.IRumorSender.html">IRumorSender</a> interface that provides the delivery of the message using the specific transport. Additionally, the method controls the delivery status. If it suspects that the peer is unavailable then it removes the peer from the list of neighbors.</p>
<h2 id="integration-with-aspnet-core">Integration with ASP.NET Core</h2>
<p><code>DotNext.AspNetCore.Cluster</code> provides implementation of HyParView protocol using HTTP transport and <a class="xref" href="../../api/DotNext.Net.Cluster.Discovery.HyParView.PeerController.html">PeerController</a> class on the top of ASP.NET Core infrastructure.</p>
<p>There are two main components of HyParView implementation that must be registered in ASP.NET Core application:</p>
<ul>
<li>Singleton service that implements <a class="xref" href="../../api/DotNext.Net.Cluster.Discovery.HyParView.PeerController.html">PeerController</a> abstract class and maintain the state of the peer</li>
<li>ASP.NET Core Middleware that is responsible for processing HyParView messages over HTTP</li>
</ul>
<p>The following code demonstrates a basic setup of HyParView:</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft.Http.Embedding;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

sealed class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        app.UseHyParViewProtocolHandler();	// informs that processing pipeline should handle HyParView-specific requests
    }

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddOptions();
    }
}

IHost host = new HostBuilder()
    .ConfigureWebHost(webHost =&gt; webHost
        .UseKestrel(options =&gt; options.ListenLocalhost(80))
        .UseStartup&lt;Startup&gt;()
    )
    .JoinMesh()  //registers all necessary services required for normal cluster node operation
    .Build();
</code></pre>
<p>Note that <code>JoinMesh</code> method should be called after <code>ConfigureWebHost</code>. Otherwise, the behavior of this method is undefined.</p>
<p><code>JoinMesh</code> method has overloads that allow to specify custom configuration section containing the configuration of the local peer.</p>
<p><code>UseHyParViewProtocolHandler</code> method should be called before registration of any authentication/authorization middleware.</p>
<h3 id="dependency-injection">Dependency Injection</h3>
<p>The application may request the following services from ASP.NET Core DI container:</p>
<ul>
<li><a class="xref" href="../../api/DotNext.Net.IPeerMesh-1.html">IPeerMesh&lt;HttpPeerClient&gt;</a> provides access to all peers visible from the local node, discovery events, configured <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient">HttpClient</a> for communication with neighbors</li>
<li><a class="xref" href="../../api/DotNext.Net.Cluster.Discovery.HyParView.PeerController.html">PeerController</a> maintains the state of the local peer, handles HyParView-specific messages and exposes <code>EnqueueBroadcastAsync</code> method for rumor spreading</li>
</ul>
<h3 id="configuration">Configuration</h3>
<p>The application should be configured properly to serve HyParView messages. The following JSON represents the example of configuration:</p>
<pre><code class="lang-json">{
    &quot;protocolVersion&quot; : &quot;http2&quot;,
    &quot;protocolVersionPolicy&quot; : &quot;RequestVersionOrLower&quot;,
    &quot;requestTimeout&quot; : &quot;00:01:00&quot;,
    &quot;clientHandlerName&quot; : &quot;HyParViewClient&quot;,
    &quot;contactNode&quot; : &quot;https://192.168.0.2:3232/&quot;,
    &quot;localNode&quot; : &quot;https://192.168.0.1:3232&quot;,
    &quot;activeViewCapacity&quot; : 5,
    &quot;passiveViewCapacity&quot; : 10,
    &quot;activeRandomWalkLength&quot; : 3,
    &quot;passiveRandomWalkLength&quot; : 2,
    &quot;shuffleActiveViewCount&quot; : 2,
    &quot;shufflePassiveViewCount&quot; : 5,
    &quot;shuffleRandomWalkLength&quot; : 2,
    &quot;queueCapacity&quot; : 15,
    &quot;lowerShufflePeriod&quot; : 1000,
    &quot;upperShufflePeriod&quot; : 1500,
}
</code></pre>
<table>
<thead>
<tr>
<th>Configuration parameter</th>
<th>Required</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>protocolVersion</td>
<td>No</td>
<td>auto</td>
<td>HTTP protocol version to be used for the communication between members. Possible values are <code>auto</code>, <code>http1</code>, <code>http2</code>, <code>http3</code></td>
</tr>
<tr>
<td>protocolVersionPolicy</td>
<td>No</td>
<td>RequestVersionOrLower</td>
<td>Specifies behaviors for selecting and negotiating the HTTP version for a request. Possible values are <code>RequestVersionExact</code>, <code>RequestVersionOrHigher</code>, <code>RequestVersionOrLower</code></td>
</tr>
<tr>
<td>requestTimeout</td>
<td>No</td>
<td>00:30:00</td>
<td>Request timeout used to access peers across the network using HTTP client</td>
</tr>
<tr>
<td>clientHandlerName</td>
<td>No</td>
<td>HyParViewClient</td>
<td>The name to be passed into <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.ihttpmessagehandlerfactory">IHttpMessageHandlerFactory</a> to create <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpmessageinvoker">HttpMessageInvoker</a> used by HyParView client code</td>
</tr>
<tr>
<td>contactNode</td>
<td>No</td>
<td>N/A</td>
<td>The address of the contact node used as an entry point to announce the local node. This property should not be specified if the local node is the first node launched as a part of the mesh</td>
</tr>
<tr>
<td>localNode</td>
<td>Yes</td>
<td>N/A</td>
<td>The addres of the local node visible by other peers in the mesh</td>
</tr>
<tr>
<td>activeViewCapacity</td>
<td>No</td>
<td>5</td>
<td>The maximum number of neighbors visible by the local node. The recommended value of this property can be calculated as <em>log(n) + c</em>, where <em>n</em> is a maximum  number of peers, <em>c</em> is a constant value. According to HyParView paper, the recommended value of <em>c</em> is 1</td>
</tr>
<tr>
<td>passiveViewCapacity</td>
<td>No</td>
<td>10</td>
<td>The maximum number of peers stored in the backlog that is used to replace the peers removed from the active view. The recommended value of this property can be calculated as <em>k(log(n) + c)</em>, where <em>k</em> is a constant value. According to HyParView paper, the recommended value of <em>k</em> is 6</td>
</tr>
<tr>
<td>activeRandomWalkLength</td>
<td>No</td>
<td>3</td>
<td>The maximum number of hops a <em>ForwardJoin</em> request is propagated</td>
</tr>
<tr>
<td>passiveRandomWalkLength</td>
<td>No</td>
<td>2</td>
<td>The value specifies at which point in the walk the peer is inserted into passive view. The value should be less than <code>activeRandomWalkLength</code> configuration property</td>
</tr>
<tr>
<td>shuffleActiveViewCount</td>
<td>No</td>
<td><code>activeViewCapacity / 2</code></td>
<td>The number of peers from active view to be included into <em>Shuffle</em> message</td>
</tr>
<tr>
<td>shufflePassiveViewCount</td>
<td>No</td>
<td><code>shufflePassiveViewCount / 2</code></td>
<td>The number of peers from passive view to be included into Shuffle message</td>
</tr>
<tr>
<td>shuffleRandomWalkLength</td>
<td>No</td>
<td><code>passiveRandomWalkLength</code></td>
<td>The maximum number of hops a Shuffle message is propagated</td>
</tr>
<tr>
<td>queueCapacity</td>
<td>No</td>
<td><code>activeViewCapacity + passiveViewCapacity</code></td>
<td>The capacity of the internal queue used to process HyParView messages</td>
</tr>
<tr>
<td>lowerShufflePeriod</td>
<td>No</td>
<td>1000</td>
<td>The lower bound of randomly selected shuffle period, in milliseconds</td>
</tr>
<tr>
<td>upperShufflePeriod</td>
<td>No</td>
<td>3000</td>
<td>The upper bound of randomly selected shuffle period</td>
</tr>
</tbody>
</table>
<p>If <em>lowerShufflePeriod</em> &lt; <em>upperShufflePeriod</em> then the actual period will be chosen randomly in the specified range. If <em>lowerShufflePeriod = upperShufflePeriod</em> then the actual period is determined by a constant value. Otherwise, the controller never sends <em>Shuffle</em> message to other peers.</p>
<h3 id="controlling-node-lifetime">Controlling node lifetime</h3>
<p>The service implementing <code>PeerController</code> abstract class is registered as singleton service. It starts receiving HyParView-specific messages immediately. Therefore, you can loose some events raised by the service such as <code>PeerDiscovered</code> at starting point. To avoid that, you can implement <a class="xref" href="../../api/DotNext.Net.Cluster.Discovery.HyParView.IPeerLifetime.html">IPeerLifetime</a> interface and register implementation as a singleton.</p>
<pre><code class="lang-csharp">using DotNext.Net;
using DotNext.Net.Cluster.Discovery.HyParView;

internal sealed class MemberLifetime : IPeerLifetime
{
	private static void OnPeerDiscovered(PeerController controller, PeerEventArgs args) {}

	void IPeerLifetime.OnStart(PeerController controller)
	{
		controller.PeerDiscovered += OnPeerDiscovered;
	}

	void IPeerLifetime.OnStop(PeerController controller)
	{
		controller.PeerDiscovered -= OnPeerDiscovered;
	}
}
</code></pre>
<h2 id="example">Example</h2>
<p>There is HyParView playground represented by HyParViewPeer application. You can find this app <a href="https://github.com/dotnet/dotNext/tree/master/src/examples/HyParViewPeer">here</a>. This playground allows to test HyParView membership protocol in real world.</p>
<p>The following command starts the first peer in the mesh:</p>
<pre><code class="lang-bash">cd &lt;dotnext&gt;/src/examples/HyParViewPeer
dotnet run -- 3262
</code></pre>
<p><em>3262</em> is a port number that can be used to access the peer. When a mesh has at least one launched peer, you can select any peer as a contact node and specify its port when starting a new node:</p>
<pre><code class="lang-bash">cd &lt;dotnext&gt;/src/examples/HyParViewPeer
dotnet run -- 3263 3262
</code></pre>
<p><em>3263</em> is a port of the started node. The second argument (port <em>3262</em>) specifies the port of the contact node. This node must be launched.</p>
<p>You can launch as many peers as you want, but the port number must be unique for each instance.</p>
<p>The terminal window of the peer will display discovery events. Each peer exposes the following HTTP resources that can be examined using Web Browser:</p>
<ul>
<li>GET <em>https://localhost:3262/neighbors</em> can be used to obtain a list of neighbors visible by the peer. You can change <em>3262</em> to the port number of the appropriate peer. According to HyParView, each peer may have partial view of the entire cluster so the list of neighbors may differ</li>
<li>GET <em>https://localhost:3262/rumor</em> can be used to spread the rumor across all peers in the mesh. The terminal window associated with each launched peer will display the identifier of the broadcast message</li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/cluster/gossip.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        </div>
      </div>
    </footer>
  </body>
</html>
