<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Cluster Programming Suite | .NEXT </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Cluster Programming Suite | .NEXT ">
      
      <link rel="icon" href="../../fav.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/cluster/index.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../doc_logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="cluster-programming-suite">Cluster Programming Suite</h1>

<p><strong>Cluster Computing</strong> is a form of distributed computing where each node set to perform the same task. The nodes usually located in the same local area network, each of them hosted on separated virtual machine or container. The cluster can be organized in various ways:</p>
<ul>
<li><em>Peer-to-peer</em> where there are no special nodes that provide a service</li>
<li><em>Master-replica</em>, or <em>leader-follower</em> where there are special <em>master</em> node that provide a service and <em>replica</em> nodes that contain a backup of <em>master</em> node. Master node performs replication to keep replicas in sync. Usually, <em>replica</em> node can replace <em>master</em> node in case of failure. Usually, this architecture relies on Distributed Consensus Algorithm for leader election and re-election in case of leader failure. The algorithm provides a guarantee that the cluster may have exactly one leader node at a time (or zero if no quorum), linearizability of operations, consistency of data.</li>
</ul>
<p>.NEXT cluster development suite provides the following features:</p>
<ol>
<li>Messaging</li>
<li><a href="https://en.wikipedia.org/wiki/Gossip_protocol">Rumor spreading</a></li>
<li><a href="https://en.wikipedia.org/wiki/Replication_(computing)">Replication</a></li>
<li><a href="https://en.wikipedia.org/wiki/Consensus_(computer_science)">Consensus</a></li>
<li>Cluster configuration management</li>
</ol>
<p>The programming model at higher level of abstraction is represented by the following interfaces:</p>
<ul>
<li><a class="xref" href="../../api/DotNext.Net.IPeer.html">IPeer</a> represents the peer in the network</li>
<li><a class="xref" href="../../api/DotNext.Net.IPeerMesh.html">IPeerMesh</a> represents a set of nodes that can communicate with each other through the network. It exposes the basic functionality for tracking of mesh events: adding or removing peers</li>
<li><a class="xref" href="../../api/DotNext.Net.IPeerMesh-1.html">IPeerMesh&lt;TPeer&gt;</a> is an extension of <code>IPeerMesh</code> interface that provides access to the peer client for communication and messaging</li>
<li><a class="xref" href="../../api/DotNext.Net.Cluster.IClusterMember.html">IClusterMember</a> represents an individual node in the cluster. This is an extension of Peer concept with high-level API</li>
<li><a class="xref" href="../../api/DotNext.Net.Cluster.ICluster.html">ICluster</a> represents the entire cluster. This is an extension of peer mesh concept with high-level API</li>
<li><a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.IMessageBus.html">IMessageBus</a> optional interface provides message-based communication between nodes in  point-to-point manner</li>
<li><a class="xref" href="../../api/DotNext.Net.Cluster.Replication.IReplicationCluster-1.html">IReplicationCluster&lt;T&gt;</a> optional interface represents a cluster where its state can be replicated across nodes to ensure consistency between them. Replication functionality based on <a class="xref" href="../../api/DotNext.IO.Log.IAuditTrail.html">IAuditTrail</a></li>
</ul>
<p>Thereby, the core model consists of two interfaces: <code>IPeer</code> and <code>IPeerMesh</code>. Other interfaces are extensions of the core model.</p>
<h1 id="messaging">Messaging</h1>
<p>Messaging feature allows to organize point-to-point communication between the nodes where individual node is able to send the message to any other node. The discrete unit of communication is represented by <a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.IMessage.html">IMessage</a> interface which is transport- and protocol-agnostic. The actual implementation should provide protocol-specific serialization and deserialization of such messages.</p>
<p>There are two types of messages:</p>
<ol>
<li><strong>Request-Reply</strong> message is similar to RPC call when caller should wait for the response. The response payload is represented by <code>IMessage</code></li>
<li><strong>One Way</strong> (or signal) message doesn't have response. It can be delivered in two ways:
1.1. With confirmation, when sender waiting for acknowledge from receiver side. As a result, it is possible to ensure that message is processed by receiver.
1.1. Without confirmation, when sender doesn't wait for acknowledge. Such kind of delivery is not reliable but very performant.</li>
</ol>
<p>The message can be transferred to the particular member using <a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.ISubscriber.html">ISubscriber</a> interface which is the extension of <code>IClusterMember</code> interface.</p>
<p>Usually, you don't to implement <code>IMessage</code> interface directly due to existence of ready-to-use realizations:</p>
<ol>
<li><a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.BinaryMessage.html">BinaryMessage</a> for raw binary content</li>
<li><a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.StreamMessage.html">StreamMessage</a> for message which payload is represented by <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.stream">Stream</a>. It it suitable for large payload when it is stored on the disk</li>
<li><a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.TextMessage.html">TextMessage</a> for textual content</li>
<li><a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.JsonMessage-1.html">JsonMessage&lt;T&gt;</a> for JSON-serializable types</li>
</ol>
<h2 id="typed-clients-and-listeners">Typed Clients and Listeners</h2>
<p><a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.IMessage.html">IMessage</a> is a low-level interface that requires a lot of boilerplate code for creating and parsing messages. It's much better to concentrate on message handling logic and hide low-level details. The same approach is used in <a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests">typed HTTP clients</a> in ASP.NET Core.</p>
<p>Typed message client or listener consists of the following parts:</p>
<ul>
<li>DTO models</li>
<li>Serialization/deserialization logic for DTO models</li>
<li>Message handling logic (for listener)</li>
</ul>
<p>Typed message client is represented by <a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.MessagingClient.html">MessagingClient</a> class. Its methods for sending messages are generic methods. The actual generic argument must represent DTO model describing the message payload and serialization/deserialization logic:</p>
<pre><code class="lang-csharp">using DotNext.IO;
using DotNext.Runtime.Serialization;

public sealed class AddMessage : ISerializable&lt;AddMessage&gt;
{
    public const string Name = &quot;Add&quot;;

    public int X { get; init; }
    public int Y { get; init; }

    public async ValueTask WriteToAsync&lt;TWriter&gt;(TWriter writer, CancellationToken token = default)
        where TWriter : notnull, IAsyncBinaryWriter
    {
        await writer.WriteInt32Async(X, true, token);
        await writer.WriteInt32Async(Y, true, token);
    }

    public static async ValueTask&lt;AddMessage&gt; ReadFromAsync&lt;TReader&gt;(TReader reader, CancellationToken token = default)
        where TReader : notnull, IAsyncBinaryReader
    {
        return new AddMessage
        {
            X = await reader.ReadInt32Async(true, token),
            Y = await reader.ReadInt32Async(true, token)
        };
    }
}
</code></pre>
<p><a class="xref" href="../../api/DotNext.Runtime.Serialization.ISerializable-1.html">ISerializable&lt;TSelf&gt;</a> interface is needed to provide serialization/deserialization logic. Thanks to static abstract methods in C#, the interface requires that the implementing type must provide deserialization logic in the form of static factory method.</p>
<p>DTO models can be shared between the client and the listener. The message type must be registered in the client. After that, sending messages via typed client is trivial:</p>
<pre><code class="lang-csharp">ISubscriber clusterMember;
var client = new MessagingClient(clusterMember).RegisterMessage&lt;AddMessage&gt;(AddMessage.Name);
await client.SendSignal(new AddMessage { X = 40, Y = 2 }); // send one-way message
</code></pre>
<p>Typed listener must inherit from <a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.MessageHandler.html">MessageHandler</a> type or instantiated using <a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.MessageHandler.Builder.html">builder</a>. Message handling logic is represented by the public instance methods.</p>
<p>For duplex (request-reply) message handler the method must follow to one of the allowed signatures:</p>
<pre><code class="lang-csharp">Task&lt;OutputMessage&gt; MethodName(InputMessage input, CancellationToken token);

Task&lt;OutputMessage&gt; MethodName(ISubscriber sender, InputMessage input, CancellationToken token);

Task&lt;OutputMessage&gt; MethodName(InputMessage input, object? context, CancellationToken token);

Task&lt;OutputMessage&gt; MethodName(ISubscriber sender, InputMessage input, object? context, CancellationToken token);
</code></pre>
<p>For one-way message handler the method must follow to one of the allowed signatures:</p>
<pre><code class="lang-csharp">Task MethodName(InputMessage input, CancellationToken token);

Task MethodName(ISubscriber sender, InputMessage input, CancellationToken token);

Task MethodName(InputMessage input, object? context, CancellationToken token);

Task MethodName(ISubscriber sender, InputMessage input, object? context, CancellationToken token);
</code></pre>
<p><code>InputMessage</code> is DTO model for the message. <em>sender</em> parameter allows to obtained information about message sender. <em>context</em> parameter supplies extra information about underlying transport for the message.</p>
<p>The following example demonstrates declaration of typed message listener:</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Messaging;
using System.Threading;
using System.Threading.Tasks;

[Message&lt;AddMessage&gt;(AddMessage.Name)]
public class TestMessageHandler : MessageHandler
{
    public Task&lt;ResultMessage&gt; AddAsync(AddMessage message, CancellationToken token)
    {
        return Task.FromResult&lt;ResultMessage&gt;(new() { Result = message.X + message.Y });
    }
}
</code></pre>
<p>In contrast to <code>MessagingClient</code>, all message types must be registered using <a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.MessageAttribute-1.html">MessageAttribute&lt;TMessage&gt;</a> attribute declaratively. However, this is not applicable when you constructing the handle using <a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.MessageHandler.Builder.html">builder</a>.</p>
<h1 id="rumor-spreading">Rumor Spreading</h1>
<p>Gossip-based messaging provides scalable way to broadcast messages across all cluster nodes. <a class="xref" href="../../api/DotNext.Net.IPeerMesh.html">IPeerMesh</a> exposes the basic functionality to discover the peers visible from the local node. The key aspect of gossiping is ability to discover neighbors. This capability is usually called <em>membership protocol</em> for Gossip-based communication. There are few approaches to achieve that:</p>
<ul>
<li><a href="https://asc.di.fct.unl.pt/%7Ejleitao/pdf/dsn07-leitao.pdf">HyParView</a> for large-scale peer meshes with hundreds or event thousands of peers</li>
<li><a href="https://research.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf">SWIM</a> for mid-size clusters where each node has weakly-consistent view of the entire cluster</li>
</ul>
<p>Currently, .NEXT offers HyParView implementation only. Read more about Gossip-based communication with .NEXT in this <a href="gossip.html">article</a>.</p>
<p>If you want to know more about infection-style communication in cluster computing then use the following links:</p>
<ul>
<li><a href="https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/">Introduction to Gossip protocols</a></li>
<li><a href="https://flopezluis.github.io/gossip-simulator/">Gossip Simulator</a></li>
<li><a href="https://bartoszsypytkowski.com/make-your-cluster-swim/">Make your cluster SWIM</a></li>
<li><a href="https://bartoszsypytkowski.com/hyparview/">HyParView: cluster membership that scales</a></li>
</ul>
<h2 id="message-ordering">Message Ordering</h2>
<p><a href="https://en.wikipedia.org/wiki/Lamport_timestamp">Lamport Timestamp</a> is a proven and simple way to preserve message order. In case of rumor spreading, it can be used to skip duplicated messages. <a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.Gossip.RumorTimestamp.html">RumorTimestamp</a> and <a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.Gossip.RumorSpreadingManager.html">RumorSpreadingManager</a> types providing a simple framework to organize deduplication of rumor during spreading.</p>
<h1 id="distributed-consensus">Distributed Consensus</h1>
<p>Consensus Algorithm allows to achieve overall reliability in the presence of faulty nodes. The most commonly used consensus algorithms are:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Chandra%E2%80%93Toueg_consensus_algorithm">Chandra-Toueg consensus algorithm</a></li>
<li><a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)">Paxos</a></li>
<li><a href="https://en.wikipedia.org/wiki/Raft_(computer_science)">Raft</a></li>
</ul>
<p>The consensus algorithm allows to choose exactly one leader node in the cluster.</p>
<p>.NEXT library provides protocol-agnostic implementation of Raft algorithm that can be adopted for any real network protocol. You can reuse this implementation which is located in <code>DotNext.Net.Cluster.Consensus.Raft</code> namespace. If you want to know more about Raft then use the following links:</p>
<ul>
<li><a href="https://raft.github.io/">The Raft Consensus Algorithm</a></li>
<li><a href="http://thesecretlivesofdata.com/">The Secret Lives of Data</a></li>
<li><a href="https://raft.github.io/raft.pdf">In Search of an Understandable Consensus Algorithm</a></li>
<li><a href="https://github.com/ongardie/dissertation">Dissertation</a></li>
</ul>
<h1 id="replication">Replication</h1>
<p>Replication allows to share information between nodes to ensure consistency between them. Usually, consensus algorithm covers replication process. In .NEXT library, replication functionality relies on the fact that each cluster node has its own persistent audit trail (or transaction log). However, the only default implementation of it is in-memory log which is suitable in siutations when your distributed application requires distributed consensus only and don't have distributed state that should be synchronized across cluster. If you need reliable replication then provide your own implementation of <a class="xref" href="../../api/DotNext.IO.Log.IAuditTrail-1.html">IAuditTrail&lt;T&gt;</a> interface or use <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.PersistentState.html">PersistentState</a> subclasses.</p>
<p><a class="xref" href="../../api/DotNext.Net.Cluster.Replication.IReplicationCluster.html">IReplicationCluster</a> interface indicates that the specific cluster implementation supports state replication across cluster nodes. It exposed access to the audit trail used to track local changes and commits on other cluster nodes.</p>
<h1 id="implementations">Implementations</h1>
<ul>
<li><a href="raft.html">.NEXT Raft</a> is a fully-featured implementation of Raft algorithm and related infrastructure</li>
<li><a href="gossip.html">.NEXT HyParView</a> is a fully-featured implementation of HyParView membership protocol for reliable Gossip-based communication</li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/cluster/index.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        </div>
      </div>
    </footer>
  </body>
</html>
